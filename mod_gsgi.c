/* 
**  mod_gsgi.c -- Apache sample gsgi module
**  [Autogenerated via ``apxs -n gsgi -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_gsgi.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /gsgi in as follows:
**
**    #   httpd.conf
**    LoadModule gsgi_module modules/mod_gsgi.so
**    <Location /gsgi>
**    SetHandler gsgi
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /gsgi and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/gsgi 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_gsgi.c
*/ 

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_log.h"
#include "ap_config.h"
#include "apr_thread_proc.h"
#include "apr_thread_cond.h"
#include <gauche.h>

module AP_MODULE_DECLARE_DATA gsgi_module;

typedef struct {
    char* script_file_path;
} gsgi_request_config;

typedef struct {
    char* script_file_path;
    char* add_load_path;
} gsgi_directory_config;

typedef struct {
} gsgi_server_config;

/**
 * gsgi daemon process
 */
typedef struct {
    apr_proc_t *process;
    apr_socket_t *socket;
} gsgi_daemon_process;

/**
 * gsgi daemon thread
 */
typedef struct {
    int id;
    int running;
    gsgi_daemon_process *daemon;
    apr_thread_t *thread;
    apr_thread_cond_t *cond;
    apr_thread_mutex_t *mutex;
} gsgi_daemon_thread;


/**
 * Initialize Gauche.
 */
static void initialize_gauche() {
    GC_INIT();
    Scm_Init(GAUCHE_SIGNATURE);
}

/**
 * Get application procedure from script.
 */
static ScmObj gsgi_get_application(request_rec* r, const char* path) {
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "path: %s", path);
    ScmLoadPacket lpak;
    if (Scm_Load(path, 0, &lpak) < 0) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "load fail: %s", path);
        return SCM_NIL;
    }
    ScmObj application = Scm_SymbolValue(Scm_UserModule(), SCM_SYMBOL(SCM_INTERN("application")));
    if (!SCM_PROCEDUREP(application)) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "application is not procedure");
        return SCM_NIL;
    }
    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, "load success: %s", path);
    return application;
}


/**
 * Build environment variables.
 */
static ScmObj build_env(request_rec *r) {
    ScmObj env = SCM_NIL;
    const char* value;

    ap_add_cgi_vars(r);
    ap_add_common_vars(r);

    value = apr_table_get(r->subprocess_env, "PATH");
    env = Scm_Acons(SCM_MAKE_STR("PATH"), SCM_MAKE_STR(value ? value : "/"), env);

    env = Scm_Acons(SCM_MAKE_STR("PATH_INFO"), SCM_MAKE_STR(r->path_info ? r->path_info : "/"), env);

    value = apr_table_get(r->subprocess_env, "PATH_TRANSLATED");
    env = Scm_Acons(SCM_MAKE_STR("PATH_TRANSLATED"), SCM_MAKE_STR(value ? value : ""), env);

    env = Scm_Acons(SCM_MAKE_STR("SERVER_PROTOCOL"), SCM_MAKE_STR(apr_table_get(r->subprocess_env, "SERVER_PROTOCOL")), env);

    value = apr_table_get(r->subprocess_env, "SERVER_ADMIN");
    env = Scm_Acons(SCM_MAKE_STR("SERVER_ADMIN"), SCM_MAKE_STR(value ? value : ""), env);
    
    value = apr_table_get(r->subprocess_env, "SERVER_SOFTWARE");
    env = Scm_Acons(SCM_MAKE_STR("SERVER_SOFTWARE"), SCM_MAKE_STR(value ? value : ""), env);
    
    value = apr_table_get(r->subprocess_env, "SERVER_NAME");
    env = Scm_Acons(SCM_MAKE_STR("SERVER_NAME"), SCM_MAKE_STR(value ? value : ""), env);

    value = apr_table_get(r->subprocess_env, "SERVER_PORT");
    env = Scm_Acons(SCM_MAKE_STR("SERVER_PORT"), SCM_MAKE_STR(value ? value : ""), env);

    value = apr_table_get(r->subprocess_env, "SCRIPT_FILENAME");
    env = Scm_Acons(SCM_MAKE_STR("SCRIPT_FILENAME"), SCM_MAKE_STR(value ? value : ""), env);
    
    value = apr_table_get(r->subprocess_env, "SCRIPT_NAME");
    env = Scm_Acons(SCM_MAKE_STR("SCRIPT_NAME"), SCM_MAKE_STR(value ? value : ""), env);
    
    value = apr_table_get(r->subprocess_env, "REMOTE_USER");
    env = Scm_Acons(SCM_MAKE_STR("REMOTE_USER"), SCM_MAKE_STR(value ? value : ""), env);

    value = apr_table_get(r->subprocess_env, "REMOTE_PORT");
    env = Scm_Acons(SCM_MAKE_STR("REMOTE_PORT"), SCM_MAKE_STR(value ? value : ""), env);

    value = apr_table_get(r->subprocess_env, "REMOTE_HOST");
    env = Scm_Acons(SCM_MAKE_STR("REMOTE_HOST"), SCM_MAKE_STR(value ? value : ""), env);

    value = apr_table_get(r->subprocess_env, "REMOTE_ADDR");
    env = Scm_Acons(SCM_MAKE_STR("REMOTE_ADDR"), SCM_MAKE_STR(value ? value : ""), env);

    value = apr_table_get(r->subprocess_env, "REMOTE_IDENT");
    env = Scm_Acons(SCM_MAKE_STR("REMOTE_IDENT"), SCM_MAKE_STR(value ? value : ""), env);

    value = apr_table_get(r->subprocess_env, "REQUEST_METHOD");
    env = Scm_Acons(SCM_MAKE_STR("REQUEST_METHOD"), SCM_MAKE_STR(value ? value : ""), env);

    value = apr_table_get(r->subprocess_env, "REQUEST_URI");
    env = Scm_Acons(SCM_MAKE_STR("REQUEST_URI"), SCM_MAKE_STR(value ? value : ""), env);

    env = Scm_Acons(SCM_MAKE_STR("REQUEST_TIME"), Scm_NumberToString(SCM_OBJ(SCM_MAKE_INT(r->request_time ? r->request_time : 0)), 10, false), env);
    
    value = apr_table_get(r->subprocess_env, "DOCUMENT_ROOT");
    env = Scm_Acons(SCM_MAKE_STR("DOCUMENT_ROOT"), SCM_MAKE_STR(value ? value : ""), env);

    env = Scm_Acons(SCM_MAKE_STR("CONTENT_TYPE"), SCM_MAKE_STR(r->content_type ? r->content_type : ""), env);

    value = apr_table_get(r->subprocess_env, "CONTENT_LENGTH");
    env = Scm_Acons(SCM_MAKE_STR("CONTENT_LENGTH"), SCM_MAKE_STR(value ? value : ""), env);

    value = apr_table_get(r->subprocess_env, "QUERY_STRING");
    env = Scm_Acons(SCM_MAKE_STR("QUERY_STRING"), SCM_MAKE_STR(value ? value : ""), env);

    value = apr_table_get(r->subprocess_env, "GATEWAY_INTERFACE");
    env = Scm_Acons(SCM_MAKE_STR("GATEWAY_INTERFACE"), SCM_MAKE_STR(value ? value : ""), env);

    env = Scm_Acons(SCM_MAKE_STR("URL_SCHEME"), SCM_MAKE_STR(r->parsed_uri.scheme ? r->parsed_uri.scheme : ""), env);
    env = Scm_Acons(SCM_MAKE_STR("HTTP_AUTH_USER"), SCM_MAKE_STR(r->parsed_uri.user ? r->parsed_uri.user : ""), env);
    env = Scm_Acons(SCM_MAKE_STR("HTTP_AUTH__PASSWORD"), SCM_MAKE_STR(r->parsed_uri.password ? r->parsed_uri.password : ""), env);
    env = Scm_Acons(SCM_MAKE_STR("URL_FRAGMENT"), SCM_MAKE_STR(r->parsed_uri.fragment ? r->parsed_uri.fragment : ""), env);

    // header
    value = apr_table_get(r->headers_in, "Referer");
    env = Scm_Acons(SCM_MAKE_STR("HTTP_REFERER"), SCM_MAKE_STR(value ? value : ""), env);

    value = apr_table_get(r->headers_in, "User-Agent");
    if (value) {
        env = Scm_Acons(SCM_MAKE_STR("HTTP_USER_AGENT"), SCM_MAKE_STR(value), env);
    }

    value = apr_table_get(r->headers_in, "Accept-Charset");
    if (value) {
        env = Scm_Acons(SCM_MAKE_STR("HTTP_ACCEPT_CHARSET"), SCM_MAKE_STR(value), env); 
    }

    value = apr_table_get(r->headers_in, "Accept-Encoding");
    if (value) {
        env = Scm_Acons(SCM_MAKE_STR("HTTP_ACCEPT_ENCODING"), SCM_MAKE_STR(value), env); 
    }

    value = apr_table_get(r->headers_in, "Accept-Language");
    if (value) {
        env = Scm_Acons(SCM_MAKE_STR("HTTP_ACCEPT_LANGUAGE"), SCM_MAKE_STR(value), env); 
    }

    value = apr_table_get(r->headers_in, "Connection");
    if (value) {
        env = Scm_Acons(SCM_MAKE_STR("HTTP_CONNECTION"), SCM_MAKE_STR(value), env); 
    }

    value = apr_table_get(r->headers_in, "Host");
    if (value) {
        env = Scm_Acons(SCM_MAKE_STR("HTTP_HOST"), SCM_MAKE_STR(value), env); 
    }

    return env;
}

/**
 * Handle status code.
 */
static void gsgi_handle_status(request_rec* r, ScmObj status) {
    r->status = SCM_INT_VALUE(status);
    r->status_line = ap_get_status_line(r->status);
}

/**
 * Handle headers.
 */
static void gsgi_handle_header(request_rec* r, ScmObj headers) {
    ScmObj rest;
    ScmObj header;
    SCM_FOR_EACH(rest, headers) {
        header = Scm_Car(rest);
        apr_table_set(r->headers_out, Scm_GetString(SCM_STRING(Scm_Car(header))), Scm_GetString(SCM_STRING(Scm_Cdr(header))));
    }
}

/**
 * Handle body.
 */
static void gsgi_handle_body(request_rec* r, ScmObj body) {
    ScmObj response = Scm_StringJoin(body, SCM_STRING(SCM_MAKE_STR("\n")), SCM_STRING_JOIN_SUFFIX);
    ap_rprintf(r, "%s", Scm_GetStringConst(SCM_STRING(response)));
}

/**
 * request config
 */

static gsgi_request_config* gsgi_allocate_request_config(apr_pool_t *p) {
    gsgi_request_config* config = (gsgi_request_config*) apr_pcalloc(p, sizeof(gsgi_request_config));
    return config;
}

static gsgi_request_config* gsgi_create_request_config(request_rec* r) {
    gsgi_request_config* config = NULL;
    config = gsgi_allocate_request_config(r->pool);
    return config;
}

/**
 * directory config.
 */
static gsgi_directory_config* gsgi_allocate_directory_config(apr_pool_t* p) {
    gsgi_directory_config* config = (gsgi_directory_config*) apr_pcalloc(p, sizeof(gsgi_directory_config));
    config->script_file_path = "";
    config->add_load_path = "";
    return config;
}

static void* gsgi_create_directory_config(apr_pool_t *p, char *dir) {
    return gsgi_allocate_directory_config(p);
}

static const char* gsgi_set_script_file_path(cmd_parms* cmd, void* mconfig, const char* arg) {
    gsgi_directory_config *config = (gsgi_directory_config*) mconfig;
    config->script_file_path = arg;
    return NULL;
}

static const char* gsgi_add_load_path(cmd_parms* cmd, void* mconfig, const char* args) {
    gsgi_directory_config *config = (gsgi_directory_config*) mconfig;
    config->add_load_path = args;
    return NULL;
}

/**
 * server config
 */
static gsgi_server_config* gsgi_allocate_server_config(apr_pool_t *p) {
    return (gsgi_server_config*) apr_pcalloc(p, sizeof(gsgi_server_config));
}

static void* gsgi_create_server_config(apr_pool_t *p, server_rec *s) {
    return gsgi_allocate_server_config(p);
}

/* The sample content handler */
static int gsgi_handler(request_rec *r)
{
    gsgi_directory_config *dconfig;
    gsgi_server_config *sconfig;
    ScmEvalPacket epak;

    int result = 0;
    if (strcmp(r->handler, "gsgi")) {
        return DECLINED;
    }
    r->content_type = "text/html";
    
    dconfig = ap_get_module_config(r->per_dir_config, &gsgi_module);
    sconfig = ap_get_module_config(r->server->module_config, &gsgi_module);

    initialize_gauche();
    ScmObj env = build_env(r);

    Scm_AddLoadPath(dconfig->add_load_path, FALSE);
    ScmObj application = gsgi_get_application(r, dconfig->script_file_path);
    if (SCM_NULLP(application)) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "gsgi application is NULL");
        return HTTP_INTERNAL_SERVER_ERROR;
    }
    result = Scm_Apply(application, SCM_LIST1(env), &epak);
    if (result <= 0) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "Scm_Apply fail");
        return HTTP_INTERNAL_SERVER_ERROR;
    }
    if (epak.numResults != 3) {
        return HTTP_INTERNAL_SERVER_ERROR;
    }
    gsgi_handle_status(r, epak.results[0]);
    gsgi_handle_header(r, epak.results[1]);
    gsgi_handle_body(r, epak.results[2]);
    return OK;
}

static void gsgi_register_hooks(apr_pool_t *p) {
    ap_hook_handler(gsgi_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

/**
 * command
 */
static const command_rec gsgi_commands[] = {
    AP_INIT_TAKE1("GSGIScriptFilePath", gsgi_set_script_file_path, NULL, ACCESS_CONF, "script file path"),
    AP_INIT_RAW_ARGS("GSGIAddLoadPath", gsgi_add_load_path, NULL, ACCESS_CONF, "add load path"),
    {NULL}
};

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA gsgi_module = {
    STANDARD20_MODULE_STUFF, 
    gsgi_create_directory_config,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,//gsgi_create_server_config,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    gsgi_commands,         /* table of config file commands       */
    gsgi_register_hooks  /* register hooks                      */
};
